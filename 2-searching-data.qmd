# Searching Data

## Task: Write and execute a search query for terms and/or phrases in one or more fields of an index

The following section will have only one full example, but will show
variations of **term** and **phrase** queries. Also, bear in mind that
when they say term they may not mean the Elasticsearch use of the word,
but rather the generic search use of the word. There are a lot of ways
to execute a search in Elasticsearch. Don't get bogged down; focus on
term and phrase searches for this section of the example.

### Example: Write and execute a basic term and phrase search

***Requirements***

-   Create an index

-   Index some documents

-   Execute a term query

-   Execute a phrase query ***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Index some documents which will create an index at the same time.
    The Elastic Console doesn't like properly formatted documents when
    calling **\_bulk** so they need to be tightly packed.

> POST /example_index/\_bulk
>
> {\"index\":{}}
>
> {\"title\":\"The quick brown fox\",\"text\":\"The quick brown fox
> jumps over the
>
> lazy dog.\"} {\"index\":{}}
>
> {\"title\":\"Fast and curious\",\"text\":\"A fast and curious fox was
> seen leaping
>
> over a lazy dog.\"}
>
> {\"index\":{}}
>
> {\"title\":\"A fox in action\",\"text\":\"In a remarkable display of
> agility, a
>
> quick fox effortlessly jumped over a dog.\"}
>
> {\"index\":{}}
>
> {\"title\":\"Wildlife wonders\",\"text\":\"Observers were amazed as
> the quick brown
>
> fox jumped over the lazy dog.\"}
>
> {\"index\":{}}
>
> {\"title\":\"Fox tales\",\"text\":\"The tale of the quick fox that
> jumped over the lazy dog has become a legend.\"}
>
> 3\. Execute a **term** query
>
> ◦ Use the GET method to search for documents containing the term
> \"Elasticsearch\" in the title field using 3 different ways to search
> at the term level (there are 10 different ways currently. Refer to the
> [[Term-level
> Queries]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/term-level-queries.html)
> documentation for the full list).
>
> GET example_index/\_search
>
> {
>
> \"query\": {
>
> \"term\": {
>
> \"title\": {
>
> \"value\": \"quick\"
>
> }
>
> }
>
> }
>
> }
>
> GET example_index/\_search
>
> {
>
> \"query\": {
>
> \"terms\": {
>
> \"text\": \[
>
> \"display\",
>
> \"amazed\"
>
> \]
>
> }
>
> }
>
> }
>
> GET example_index/\_search
>
> {
>
> \"query\": {
>
> \"terms_set\" : {
>
> \"text\" : {
>
> \"terms\": \[ \"quick\", \"over\", \"display\" \],
>
> \"minimum_should_match\" : 3
>
> }
>
> }
>
> }
>
> }
>
> 4\. Execute a **phrase** query
>
> // returns 2 docs
>
> GET /example_index/\_search
>
> {
>
> \"query\": {
>
> \"match_phrase\": {
>
> \"text\": \"quick brown fox\"
>
> }
>
> }
>
> }
>
> // returns 1 doc
>
> GET /example_index/\_search
>
> {
>
> \"query\": {
>
> \"match_phrase_prefix\": {
>
> \"text\": \"fast and curi\"
>
> }
>
> }
>
> }
>
> // returns 1 doc
>
> GET /example_index/\_search
>
> {
>
> \"query\": {
>
> \"query_string\": {
>
> \"default_field\": \"text\",
>
> \"query\": \"\\\"fox jumps\\\"\"
>
> }
>
> }
>
> }

***Considerations***

-   The default **standard analyzer** (lowercasing, whitespace
    tokenization, basic normalization) is used.

-   The **term** query is used for exact matches and is not analyzed,
    meaning it matches the exact term in the inverted index.

-   The **match_phrase** query analyzes the input text and matches it as
    a phrase, making it useful for finding exact sequences of terms.

***Test***

1\. Verify the various queries return the proper results ***Clean-up
(optional)***

• Delete the example index

DELETE example_index ***Documentation***

-   [[Full Text
    Queries]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/full-text-queries.html)

-   [[Match Phrase
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/8.13/query-dsl-match-query-phrase.html)

-   [[Match Phrase Prefix
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/8.13/query-dsl-match-query-phrase-prefix.html)

-   [[Query
    DSL]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/8.13/query-dsl.html)

-   [[Term-level
    Queries]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/term-level-queries.html)

## Task: Write and execute a search query that is a Boolean combination of multiple queries and filters

### Example 1: Creating a Boolean search for documents in a book index

***Requirements***

 Search for documents with a term in the \"title\", \"description\",
and \"category\" field

***Steps***

1.  **Open the Kibana Console** or use a REST client.

2.  Index some documents which will create an index at the same time.
    The Elastic Console doesn't like properly formatted documents when
    calling **\_bulk** so they need to be tightly packed.

> POST /books/\_bulk
>
> { \"index\": { \"\_id\": \"1\" } }
>
> { \"title\": \"To Kill a Mockingbird\", \"description\": \"A novel
> about the serious
>
> issues of rape and racial inequality.\", \"category\": \"Fiction\" }
>
> { \"index\": { \"\_id\": \"2\" } }
>
> { \"title\": \"1984\", \"description\": \"A novel that delves into the
> dangers of
>
> totalitarianism.\", \"category\": \"Dystopian\" }
>
> { \"index\": { \"\_id\": \"3\" } }
>
> { \"title\": \"The Great Gatsby\", \"description\": \"A critique of
> the American
>
> Dream.\", \"category\": \"Fiction\" }
>
> { \"index\": { \"\_id\": \"4\" } }
>
> { \"title\": \"Moby Dick\", \"description\": \"The quest of Ahab to
> exact revenge on
>
> the whale Moby Dick.\", \"category\": \"Adventure\" }
>
> { \"index\": { \"\_id\": \"5\" } }
>
> { \"title\": \"Pride and Prejudice\", \"description\": \"A romantic
> novel that also critiques the British landed gentry at the end of the
> 18th century.\",
>
> \"category\": \"Romance\" }

3.  Create a boolean search query . The order in which the various
    clauses are added don't matter to the final result.

> GET books/\_search
>
> {
>
> **\"query\": {**
>
> **\"bool\": {**
>
> **}**
>
> **}**
>
> }

4.  Add a **must** query for the description field. This will return 4
    documents.

> GET books/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> **\"must\": \[**
>
> **{**
>
> **\"terms\": {**
>
> **\"description\": \[**
>
> **\"novel\",**
>
> **\"dream\",**
>
> **\"critique\"**
>
> **\]**
>
> **}**
>
> **}**
>
> **\]**
>
> }
>
> }
>
> }
>
> 5\. Add a **filter** query for the category field. This will return 2
> documents.
>
> GET books/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"must\": \[
>
> {
>
> \"terms\": {
>
> \"description\": \[
>
> \"novel\",
>
> \"dream\",
>
> \"critique\"
>
> \]
>
> }
>
> }
>
> \]**,**
>
> **\"filter\": \[**
>
> **{**
>
> **\"term\": {**
>
> **\"category\": \"fiction\"**
>
> **}**
>
> **}**
>
> **\]**
>
> }
>
> }
>
> }
>
> 6\. Add a must_not filter for the title field. This will return 1
> document.
>
> GET books/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"must\": \[
>
> {
>
> \"terms\": {
>
> \"description\": \[
>
> \"novel\",
>
> \"dream\",
>
> \"critique\"
>
> \]
>
> }
>
> }
>
> \],
>
> \"filter\": \[
>
> {
>
> \"term\": {
>
> \"category\": \"fiction\"
>
> }
>
> }
>
> \],
>
> \"must_not\": \[
>
> {
>
> \"term\": {
>
> \"title\": {
>
> \"value\": \"gatsby\"
>
> }
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }
>
> 7\. Execute the final search query
>
> GET books/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"must\": \[
>
> {
>
> \"terms\": {
>
> \"description\": \[
>
> \"novel\",
>
> \"dream\",
>
> \"critique\"
>
> \]
>
> }
>
> }
>
> \],
>
> \"filter\": \[
>
> {
>
> \"term\": {
>
> \"category\": \"fiction\"
>
> }
>
> }
>
> \],
>
> \"must_not\": \[
>
> {
>
> \"term\": {
>
> \"title\": {
>
> \"value\": \"gatsby\"
>
> }
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }

***Considerations***

-   The bool query allows for combining multiple queries and filters
    with Boolean logic

-   The must, must_not, and filter clauses ensure that all searches and
    filters must match for a document to be returned ***Test***

> 1\. Verify that the search query returns documents with the term
> \"novel\", "dream", and "critique" in the \"description\" field. Why
> are there no documents with the term "critique"?

***Clean-up (optional)*** • Delete the index

DELETE books ***Documentation***

-   [[Elasticsearch Boolean
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html)

-   [[Elasticsearch Match
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)

-   [[Elasticsearch Range
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)

-   [[Elasticsearch Term
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)

### Example 2: Creating a Boolean search for finding products within a specific price range and excluding discontinued items

***Requirements***

-   Find all documents where the name field exists (name: \*) and the
    price field falls within a specified range.

-   Additionally, filter out any documents where the discontinued field
    is set to true.

**Steps**

1.  **Open the Kibana Console** or use a REST client.

2.  Index some documents which will create an index at the same time.
    The Elastic Console doesn't like properly formatted documents when
    calling **\_bulk** so they need to be tightly packed.

> POST /products/\_bulk
>
> {\"index\":{\"\_id\":1}}
>
> {\"name\":\"Coffee Maker\",\"price\":49.99,\"discontinued\":false}
>
> {\"index\":{\"\_id\":2}}
>
> {\"name\":\"Gaming Laptop\",\"price\":1299.99,\"discontinued\":false}
>
> {\"index\":{\"\_id\":3}}
>
> {\"name\":\"Wireless
> Headphones\",\"price\":79.99,\"discontinued\":true}
>
> {\"index\":{\"\_id\":4}}
>
> {\"name\":\"Smartwatch\",\"price\":249.99,\"discontinued\":false}
>
> 2\. Construct the search query
>
> GET products/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"must\": \[
>
> {
>
> \"range\": {
>
> \"price\": {
>
> \"gte\": 10,
>
> \"lte\": 300
>
> }
>
> }
>
> }
>
> \],
>
> \"must_not\": \[
>
> {
>
> \"match\": {
>
> \"discontinued\": true
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }

***Explanation***

-   Similar to the previous example, the bool query combines multiple
    conditions.

-   The must clause specifies documents that must match all conditions
    within it.

-   The range query ensures the price field is between \$10 (inclusive)
    and \$300 (inclusive).

-   The must_not clause excludes documents that match the specified
    criteria.

-   The match query filters out documents where the discontinued field
    is set to true.

***Test***

> 1\. Run the search query and verify the results only include documents
> for products with:

-   A price between \$10 and \$300 (inclusive).

-   discontinued set to true (not discontinued).

This should return documents with IDs 1 and 4 (Coffee Maker and
Smartwatch) based on the sample data.

***Considerations***

-   The chosen price range (gte: 10, lte: 300) can be adjusted based on
    your specific needs.

-   You can modify the match query for the name field to use more
    specific criteria if needed. ***Clean-up (optional)*** • Delete the
    index

> DELETE products

***Documentation***

-   [[Elasticsearch Boolean
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html)

-   [[Elasticsearch Match
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)

-   [[Elasticsearch Range
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)

-   [[Elasticsearch Term
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)

### Example 3: Creating a Boolean search for e-commerce products

***Requirements***

-   Search for products that belong to the \"Electronics\" category

-   The product name should contain the term \"phone\"

-   Exclude products with a price greater than 500

***Steps***

1.  **Open the Kibana Console** or use a REST client.

2.  Index some documents which will create an index at the same time.
    The Elastic Console doesn't like properly formatted documents when
    calling **\_bulk** so they need to be tightly packed.

> POST /products/\_bulk
>
> {\"index\": { \"\_id\":1 } }
>
> { \"name\": \"Smartphone X\", \"category\": \"Electronics\",
> \"price\": 399.99 }
>
> {\"index\": { \"\_id\":2 } }
>
> { \"name\": \"Laptop Y\", \"category\": \"Electronics\", \"price\":
> 799.99 }
>
> {\"index\": { \"\_id\":3 } }
>
> { \"name\": \"Headphones Z\", \"category\": \"Electronics\",
> \"price\": 99.99 }
>
> {\"index\": { \"\_id\":4 } }
>
> { \"name\": \"Gaming Console\", \"category\": \"Electronics\",
> \"price\": 299.99 }

3.  Start with a boolean query that only matches the category
    **electronics**. This returns 4 documents

> GET /products/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"must\": \[
>
> {
>
> \"term\": {
>
> \"category\": \"electronics\"
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }
>
> 4\. Add a should clause for the word **phone**. This still returns 4
> documents (why?).
>
> GET /products/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"must\": \[
>
> {
>
> \"term\": {
>
> \"category\": \"electronics\"
>
> }
>
> }
>
> \],
>
> \"should\": \[
>
> {
>
> \"match\": {
>
> \"name\": \"phone\"
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }
>
> 5\. Add a must_not clause for the any **price** greater than
> **\$300**. This still returns 2 documents (why?).
>
> GET /products/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"must\": \[
>
> {
>
> \"term\": {
>
> \"category\": \"electronics\"
>
> }
>
> }
>
> \],
>
> \"should\": \[
>
> {
>
> \"match\": {
>
> \"name\": \"phone\"
>
> }
>
> }
>
> \],
>
> \"must_not\": \[
>
> {
>
> \"range\": {
>
> \"price\": {
>
> \"gt\": 300
>
> }
>
> }
>
> }
>
> \]
>
> }
>
> }

} ***Test***

> 1\. The search results should include the following documents:
>
> ◦ Headphones Z
>
> ◦ Gaming Console

***Considerations***

-   The term query is used for exact matches on the category field.

-   The match query is used for matches on the name field.

-   The range query is used to filter out documents based on the price
    field.

-   The bool query combines these conditions using the specified
    occurrence types. ***Clean-up (optional)***

• Delete the index

DELETE products ***Documentation***

-   [[Elasticsearch Boolean
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html)

-   [[Elasticsearch Match
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)

-   [[Elasticsearch Range
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)

-   [[Elasticsearch Term
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)

### Example 4: Creating a Boolean search for e-commerce products

***Requirements***

-   Create an index named \"products\"

-   Create at least 4 documents with varying categories, prices,
    ratings, and brands

-   Use the \"must\", \"should\", \"must_not\", and \"filter\" clauses
    in the Boolean query

-   The query should return products that match the specified criteria
    and are from a specific brand

***Steps***

1.  **Open the Kibana Console** or use a REST client.

2.  Create the \"products\" index and add some sample documents using
    the /\_bulk endpoint

> POST /products/\_bulk
>
> {\"index\":{\"\_id\":1}}
>
> {\"name\":\"Laptop\",\"category\":\"Electronics\",\"price\":1200,\"rating\":4.5,\"brand\":\"
>
> Apple\"}
>
> {\"index\":{\"\_id\":2}}
>
> {\"name\":\"Smartphone\",\"category\":\"Electronics\",\"price\":800,\"rating\":4.2,\"brand
>
> \":\"Samsung\"}
>
> {\"index\":{\"\_id\":3}}
>
> {\"name\":\"Sofa\",\"category\":\"Furniture\",\"price\":1000,\"rating\":3.8,\"brand\":\"IKEA
>
> \"}
>
> {\"index\":{\"\_id\":4}}
>
> {\"name\":\"Headphones\",\"category\":\"Electronics\",\"price\":150,\"rating\":2.5,\"brand
>
> \":\"Sony\"}
>
> {\"index\":{\"\_id\":5}}
>
> {\"name\":\"Dining
>
> Table\",\"category\":\"Furniture\",\"price\":600,\"rating\":4.1,\"brand\":\"Ashley\"}
>
> 3\. Start with a boolean query that only matches the category
> **electronics**. This returns 3 documents
>
> GET /products/\_search
>
> {
>
> \"query\": {
>
> **\"bool\": {**
>
> **\"should\": \[**
>
> **{**
>
> **\"term\": {**
>
> **\"category\": \"electronics\"**
>
> **}**
>
> **}**
>
> **\]**
>
> **}**
>
> }
>
> }
>
> 4\. Add a must clause to only return products whose price is greater
> than \$500. This should return 4 documents (why?)
>
> GET /products/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"should\": \[
>
> {
>
> \"term\": {
>
> \"category\": \"electronics\"
>
> }
>
> }
>
> \],
>
> **\"must\": \[**
>
> **{**
>
> **\"range\": {**
>
> **\"price\": {**
>
> **\"gte\": 500**
>
> **}**
>
> **}**
>
> **}**
>
> **\]**
>
> }
>
> }
>
> }
>
> 5\. Add a must_not clause to exclude items with a rating less than 4.
> This will return 3 documents
>
> GET /products/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"should\": \[
>
> {
>
> \"term\": {
>
> \"category\": \"electronics\"
>
> }
>
> }
>
> \],
>
> \"must\": \[
>
> {
>
> \"range\": {
>
> \"price\": {
>
> \"gte\": 500
>
> }
>
> }
>
> }
>
> \],
>
> \"must_not\": \[
>
> {
>
> \"range\": {
>
> \"rating\": {
>
> \"lt\": 4
>
> }
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }
>
> 6\. Add the final filter to only return Apple products. This should
> return 1 document
>
> GET /products/\_search
>
> {
>
> \"query\": {
>
> \"bool\": {
>
> \"should\": \[
>
> {
>
> \"term\": {
>
> \"category\": \"electronics\"
>
> }
>
> }
>
> \],
>
> \"must\": \[
>
> {
>
> \"range\": {
>
> \"price\": {
>
> \"gte\": 500
>
> }
>
> }
>
> }
>
> \],
>
> \"must_not\": \[
>
> {
>
> \"range\": {
>
> \"rating\": {
>
> \"lt\": 4
>
> }
>
> }
>
> }
>
> \],
>
> \"filter\": \[
>
> {
>
> \"term\": {
>
> \"brand\": \"apple\"
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }

***Test***

-   Check the response from the search query to ensure that it returns
    the expected documents (products in the \"Electronics\" category or
    with a price greater than \$500, but excluding products with a
    rating less than 4, and from the brand \"Apple\").

***Considerations***

-   The filter clause is used to include only documents with the brand
    **Apple**. ***Clean-up (optional)*** • Delete the index

> DELETE products

***Documentation***

-   [[Elasticsearch Boolean
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html)

-   [[Elasticsearch Term
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)

-   [[Elasticsearch Range
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)

## Task: Create an asynchronous search

Asynchronous search uses the same parameters as regular search with a
few extra features listed in their entirety in the document listed
below. For example, in the solution below the size option is from the
[[Search
API]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/8.13/search-search.html).
There is only one example here as you can look up the other options as
needed during the exam.

### Example 1: Executing an asynchronous search on a large log index

***Requirements***

-   An Elasticsearch index named \"logs\" with a large number of
    documents (e.g., millions of log entries)

-   Perform a search on the \"logs\" index that may take a long time to
    complete due to the size of the index

-   Retrieve the search results asynchronously without blocking the
    client

***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Submit an asynchronous search request (if logs doesn't exist as an
    index then switch to an existing index)

> POST /logs/\_async_search
>
> {
>
> \"query\": {
>
> \"match_all\": {}
>
> },
>
> \"size\": 10000,
>
> \"wait_for_completion_timeout\": \"30s\"
>
> }
>
> This request will return an id and a response object containing
> partial results if available within the specified timeout.

3.  Check the status of the asynchronous search using the id

> GET /\_async_search/status/{id}

4.  Retrieve the search results using the id:

> GET /\_async_search/results/{id}

***Test***

1.  Index a large number of sample log documents in the \"logs\" index
    or use an index with a large number of documents.

2.  Execute the asynchronous search request and store the returned
    **id**.

3.  Periodically check the status of the search using the id and the
    /\_async_search/status/{id} endpoint.

> GET /\_async_search/status/{id}

4.  Once the search is complete, retrieve the final results using the
    **id** and the /\_async_search/results/{id} endpoint.

> GET /\_async_search/results/{id}

***Considerations***

-   The \_async_search endpoint is used to submit an asynchronous search
    request.

-   The wait_for_completion_timeout parameter specifies the maximum time
    to wait for partial results before returning.

-   The **id** returned by the initial request is used to check the
    status and retrieve the final results.

-   Asynchronous search is useful for long-running searches on large
    datasets, as it doesn\'t block the client while the search is being
    processed.

***Clean-up (optional)***

• If you created an index for this example you might want to delete it

***Documentation***

-   [[Elasticsearch Async Search
    API]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html)

-   [[Submitting Async
    Search]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html#async-search-submit)

-   [[Retrieving Async Search
    Results]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html#async-search-results)

## Task: Write and execute metric and bucket aggregations

### Example 1: Creating Metric and Bucket Aggregations for Product Prices

***Requirements***

-   Create an index.

-   Index at least four documents using the \_bulk endpoint.

-   Execute metric and bucket aggregations.

***Steps***

1.  **Open the Kibana Console** or use a REST client

 Ensure you have access to Kibana or any REST client to execute the
following requests.

2.  Create an index with the following schema (needed for the
    aggregations to work properly)

> PUT product_prices
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"product\": {
>
> \"type\": \"text\"
>
> },
>
> \"category\": {
>
> \"type\": \"keyword\"
>
> },
>
> \"price\": {
>
> \"type\": \"double\"
>
> }
>
> }
>
> }
>
> }

3.  Index documents

> POST /product_prices/\_bulk
>
> { \"index\": { \"\_id\": \"1\" } }
>
> { \"product\": \"Elasticsearch Guide\", \"category\": \"Books\",
> \"price\": 29.99 }
>
> { \"index\": { \"\_id\": \"2\" } }
>
> { \"product\": \"Advanced Elasticsearch\", \"category\": \"Books\",
> \"price\": 39.99 }
>
> { \"index\": { \"\_id\": \"3\" } }
>
> { \"product\": \"Elasticsearch T-shirt\", \"category\": \"Apparel\",
> \"price\": 19.99 }
>
> { \"index\": { \"\_id\": \"4\" } }
>
> { \"product\": \"Elasticsearch Mug\", \"category\": \"Apparel\",
> \"price\": 12.99 }

4.  Execute a simple aggregation (should return 2 buckets)

> GET product_prices/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"categories\": {
>
> \"terms\": {
>
> \"field\": \"category\"
>
> }
>
> }
>
> }
>
> }
>
> 5\. Add and execute a single aggregation
>
> GET product_prices/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"categories\": {
>
> \"terms\": {
>
> \"field\": \"category\"
>
> },
>
> **\"aggs\": {**
>
> **\"average_price\": {**
>
> **\"avg\": {**
>
> **\"field\": \"price\"**
>
> **}**
>
> **}**
>
> **}**
>
> }
>
> }
>
> }

6\. Add two more aggregations and execute the query

> GET /product_prices/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"categories\": {
>
> \"terms\": {
>
> \"field\": \"category\"
>
> },
>
> \"aggs\": {
>
> \"average_price\": {
>
> \"avg\": {
>
> \"field\": \"price\"
>
> }
>
> },
>
> **\"max_price\": {**
>
> **\"max\": {**
>
> **\"field\": \"price\"**
>
> **}**
>
> **},**
>
> **\"min_price\": {**
>
> **\"min\": {**
>
> **\"field\": \"price\"**
>
> **}**
>
> **}**
>
> }
>
> }
>
> }
>
> }

***Test***

1.  Verify the index creation

> GET /product_prices

2.  Verify the documents have been index

> GET /product_prices/\_search

3.  Execute the aggregation query and verify the results

> GET /product_prices/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"categories\": {
>
> \"terms\": {
>
> \"field\": \"category\"
>
> },
>
> \"aggs\": {
>
> \"average_price\": {
>
> \"avg\": {
>
> \"field\": \"price\"
>
> }
>
> },
>
> \"max_price\": {
>
> \"max\": {
>
> \"field\": \"price\"
>
> }
>
> },
>
> \"min_price\": {
>
> \"min\": {
>
> \"field\": \"price\"
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> 4\. Using the documents above you should see a response like this:
>
> {
>
> \"took\": 2,
>
> \"timed_out\": false,
>
> \"\_shards\": {
>
> \"total\": 1,
>
> \"successful\": 1,
>
> \"skipped\": 0,
>
> \"failed\": 0
>
> },
>
> \"hits\": {
>
> \"total\": {
>
> \"value\": 4,
>
> \"relation\": \"eq\"
>
> },
>
> \"max_score\": null,
>
> \"hits\": \[\]
>
> },
>
> **\"aggregations\": {**
>
> **\"categories\": {**
>
> **\"doc_count_error_upper_bound\": 0,**
>
> **\"sum_other_doc_count\": 0,**
>
> **\"buckets\": \[**
>
> **{**
>
> **\"key\": \"Apparel\",**
>
> **\"doc_count\": 2,**
>
> **\"average_price\": {**
>
> **\"value\": 16.49**
>
> **},**
>
> **\"max_price\": {**
>
> **\"value\": 19.99**
>
> **},**
>
> **\"min_price\": {**
>
> **\"value\": 12.99**
>
> **}**
>
> **},**
>
> **{**
>
> **\"key\": \"Books\",**
>
> **\"doc_count\": 2,**
>
> **\"average_price\": {**
>
> **\"value\": 34.99**
>
> **},**
>
> **\"max_price\": {**
>
> **\"value\": 39.99**
>
> **},**
>
> **\"min_price\": {**
>
> **\"value\": 29.99**
>
> **}**
>
> **}**
>
> **\]**
>
> **}**
>
> **}**
>
> }

***Considerations***

-   The category field must be of type keyword

-   The terms aggregation creates buckets for each unique category.

-   The avg, max, and min sub-aggregations calculate the average,
    maximum, and minimum prices within each category bucket.

-   Setting size to 0 ensures that only aggregation results are
    returned, not individual documents. ***Clean-up (optional)***

• Delete the index

DELETE product_prices ***Documentation***

-   [[Elasticsearch:
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)

-   [[Elasticsearch: Terms
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html)

-   [[Elasticsearch: Avg
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-avg-aggregation.html)

-   [[Elasticsearch: Max
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-max-aggregation.html)

-   [[Elasticsearch:
    Min]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-min-aggregation.html)

> [[Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-min-aggregation.html)
> [https://docs.google.com/document/d/1ZLxhNbz5TBpts0t24KzHmXtcj9OGUS1ah0
> rDdoOecgU/edit?usp=sharing]{.underline}

### Example 2: Creating Metric and Bucket Aggregations for Website Traffic

***Requirements***

-   Create a new index with four documents representing website traffic
    data

-   Use the \"sum\" metric aggregation to calculate the total page views

-   Use the \"terms\" bucket aggregation to group traffic by country

-   Use the \"avg\" metric aggregation to calculate the average page
    views per country

***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Create a new index (in order to create a bucket using country it has
    to be of type keyword)

> PUT traffic
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"country\": {
>
> \"type\": \"keyword\"
>
> },
>
> \"page_views\": {
>
> \"type\": \"long\"
>
> }
>
> }
>
> }
>
> }
>
> 3\. Add four documents representing website traffic data
>
> POST /traffic/\_bulk
>
> {\"index\":{}}
>
> {\"country\":\"USA\",\"page_views\":100}
>
> {\"index\":{}}
>
> {\"country\":\"USA\",\"page_views\":200}
>
> {\"index\":{}}
>
> {\"country\":\"Canada\",\"page_views\":50}
>
> {\"index\":{}}
>
> {\"country\":\"Canada\",\"page_views\":75}
>
> 3\. Execute the metric and bucket aggregations
>
> GET /traffic/\_search
>
> {
>
> \"aggs\": {
>
> \"total_page_views\": {
>
> \"sum\": {
>
> \"field\": \"page_views\"
>
> }
>
> },
>
> \"traffic_by_country\": {
>
> \"terms\": {
>
> \"field\": \"country\"
>
> },
>
> \"aggs\": {
>
> \"avg_page_views\": {
>
> \"avg\": {
>
> \"field\": \"page_views\"
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }

***Test***

1.  Verify that the total page views are calculated correctly (should be
    425)

> GET /traffic/\_search
>
> {
>
> \"aggs\": {
>
> \"total_page_views\": {
>
> \"sum\": {
>
> \"field\": \"page_views\"
>
> }
>
> }
>
> }
>
> }

2.  Verify that the traffic is grouped correctly by country and average
    page views are calculated

> GET /traffic/\_search
>
> {
>
> \"aggs\": {
>
> \"traffic_by_country\": {
>
> \"terms\": {
>
> \"field\": \"country\"
>
> },
>
> \"aggs\": {
>
> \"avg_page_views\": {
>
> \"avg\": {
>
> \"field\": \"page_views\"
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> Response:
>
> {
>
> \"took\": 1,
>
> \"timed_out\": false,
>
> \"\_shards\": {
>
> \"total\": 1,
>
> \"successful\": 1,
>
> \"skipped\": 0,
>
> \"failed\": 0
>
> },
>
> \"hits\": {
>
> \"total\": {
>
> \"value\": 4,
>
> \"relation\": \"eq\"
>
> },
>
> \"max_score\": null,
>
> \"hits\": \[\]
>
> },
>
> \"aggregations\": {
>
> **\"total_page_views\": {**
>
> **\"value\": 425**
>
> **},**
>
> \"traffic_by_country\": {
>
> \"doc_count_error_upper_bound\": 0,
>
> \"sum_other_doc_count\": 0,
>
> **\"buckets\": \[**
>
> **{**
>
> **\"key\": \"Canada\",**
>
> **\"doc_count\": 2,**
>
> **\"avg_page_views_by_country\": {**
>
> **\"value\": 62.5**
>
> **}**
>
> **},**
>
> **{**
>
> **\"key\": \"USA\",**
>
> **\"doc_count\": 2,**
>
> **\"avg_page_views_by_country\": {**
>
> **\"value\": 150**
>
> **}**
>
> **}**
>
> **\]**
>
> }
>
> }
>
> }

***Considerations***

-   The country field must be of type keyword

-   The \"sum\" metric aggregation is used to calculate the total page
    views.

-   The \"terms\" bucket aggregation is used to group traffic by
    country.

-   The \"avg\" metric aggregation is used to calculate the average page
    views per country. ***Clean-up (optional)*** • Delete the index

> DELETE traffic

***Documentation***

-   [[Elasticsearch
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)

-   [[Metric
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html)

-   [[Bucket
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html)

-   [[Terms
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html)

### Example 3: Creating Metric and Bucket Aggregations for Analyzing Employee Salaries

***Requirements***

-   An Elasticsearch index named \"employees\" with documents containing
    fields like \"name\", \"department\", \"position\", \"salary\",
    \"hire_date\", etc.

-   Calculate the average salary across all employees

-   Group the employees by department and calculate the maximum salary
    for each department

***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Create an index with the proper mapping for department as we want to
    bucket by it

> PUT employees
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"name\" : {
>
> \"type\": \"text\"
>
> },
>
> \"department\" : {
>
> \"type\": \"keyword\"
>
> },
>
> \"position\" : {
>
> \"type\": \"text\"
>
> },
>
> \"salary\" : {
>
> \"type\": \"integer\"
>
> },
>
> \"hire_date\" : {
>
> \"type\": \"date\"
>
> }
>
> }
>
> }
>
> }
>
> 3\. Index sample employee documents using the /\_bulk endpoint:
>
> POST /employees/\_bulk
>
> {\"index\":{\"\_id\":1}}
>
> {\"name\":\"John Doe\", \"department\":\"Engineering\",
> \"position\":\"Software
>
> Engineer\", \"salary\":80000, \"hire_date\":\"2018-01-15\"}
>
> {\"index\":{\"\_id\":2}}
>
> {\"name\":\"Jane Smith\", \"department\":\"Engineering\",
> \"position\":\"DevOps
>
> Engineer\", \"salary\":75000, \"hire_date\":\"2020-03-01\"}
>
> {\"index\":{\"\_id\":3}}
>
> {\"name\":\"Bob Johnson\", \"department\":\"Sales\",
> \"position\":\"Sales Manager\",
>
> \"salary\":90000, \"hire_date\":\"2016-06-01\"}
>
> {\"index\":{\"\_id\":4}}
>
> {\"name\":\"Alice Williams\", \"department\":\"Sales\",
> \"position\":\"Sales
>
> Representative\", \"salary\":65000, \"hire_date\":\"2019-09-15\"}
>
> 3\. Define the aggregation query GET employees/\_search
>
> {
>
> \"size\" : 0,
>
> \"aggs\": {
>
> \"avg_salary_all_emps\": {
>
> \"avg\": {
>
> \"field\": \"salary\"
>
> }
>
> },
>
> \"max_salary_by_department\" : {
>
> \"terms\": {
>
> \"field\": \"department\"
>
> },
>
> \"aggs\": {
>
> \"max_salary\": {
>
> \"max\": {
>
> \"field\": \"salary\"
>
> }
>
> }
>
> }
>
> }
>
> }

} ***Test***

• Execute the aggregation query, and it should return the following:

> {
>
> \"took\": 1,
>
> \"timed_out\": false,
>
> \"\_shards\": {
>
> \"total\": 1,
>
> \"successful\": 1,
>
> \"skipped\": 0,
>
> \"failed\": 0
>
> },
>
> \"hits\": {
>
> \"total\": {
>
> \"value\": 4,
>
> \"relation\": \"eq\"
>
> },
>
> \"max_score\": null,
>
> \"hits\": \[\]
>
> },
>
> **\"aggregations\": {**
>
> **\"avg_salary_all_emps\": {**
>
> **\"value\": 77500**
>
> **},**
>
> **\"max_salary_by_department\": {**
>
> **\"doc_count_error_upper_bound\": 0,**
>
> **\"sum_other_doc_count\": 0,**
>
> **\"buckets\": \[**
>
> **{**
>
> **\"key\": \"Engineering\",**
>
> **\"doc_count\": 2,**
>
> **\"max_salary\": {**
>
> **\"value\": 80000**
>
> **}**
>
> **},**
>
> **{**
>
> **\"key\": \"Sales\",**
>
> **\"doc_count\": 2,**
>
> **\"max_salary\": {**
>
> **\"value\": 90000**
>
> **}**
>
> **}**
>
> **\]**
>
> **}**
>
> **}**
>
> }

***Considerations***

-   The department field must be of type keyword

-   The size parameter is set to 0 to exclude hit documents from the
    response.

-   The avg_salary metric aggregation calculates the average of the
    \"salary\" field across all documents.

-   The max_salary_by_departments bucket aggregation groups the
    documents by the department field.

-   Inside the max_salary_by_departments aggregation, the max_salary
    metric sub-aggregation calculates the maximum value of the salary
    field for each department. ***Clean-up (optional)*** • Delete the
    index

> DELETE employees

***Documentation***

-   [[Elasticsearch
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)

-   [[Metric
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html)

-   [[Bucket
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html)

-   [[Terms
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html)

## Task: Write and execute aggregations that contain subaggregations

### Example 1: Creating aggregations and sub-aggregations for Product Categories and Prices

***Requirements***

-   Create an index

-   Index at least four documents using the \_bulk endpoint

-   Execute aggregations by category and sub-aggregations by price

***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Create an index

> PUT /product_index
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"product\": {
>
> \"type\": \"text\"
>
> },
>
> \"category\": {
>
> \"type\": \"keyword\"
>
> },
>
> \"price\": {
>
> \"type\": \"double\"
>
> }
>
> }
>
> }
>
> }

3.  Index some sample documents

> POST /product_index/\_bulk
>
> { \"index\": { \"\_id\": \"1\" } }
>
> { \"product\": \"Elasticsearch Guide\", \"category\": \"Books\",
> \"price\": 29.99 }
>
> { \"index\": { \"\_id\": \"2\" } }
>
> { \"product\": \"Advanced Elasticsearch\", \"category\": \"Books\",
> \"price\": 39.99 }
>
> { \"index\": { \"\_id\": \"3\" } }
>
> { \"product\": \"Elasticsearch T-shirt\", \"category\": \"Apparel\",
> \"price\": 19.99 }
>
> { \"index\": { \"\_id\": \"4\" } }
>
> { \"product\": \"Elasticsearch Mug\", \"category\": \"Apparel\",
> \"price\": 12.99 }

4.  Execute an aggregation by category

> GET /product_index/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"categories\": {
>
> \"terms\": {
>
> \"field\": \"category\"
>
> }
>
> }
>
> }
>
> }
>
> 5\. Add sub-aggregations by price
>
> GET /product_index/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"categories\": {
>
> \"terms\": {
>
> \"field\": \"category\"
>
> },
>
> \"aggs\": {
>
> \"average_price\": {
>
> \"avg\": {
>
> \"field\": \"price\"
>
> }
>
> },
>
> \"price_ranges\": {
>
> \"range\": {
>
> \"field\": \"price\",
>
> \"ranges\": \[
>
> { \"to\": 20 },
>
> { \"from\": 20, \"to\": 40 },
>
> { \"from\": 40 }
>
> \]
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }

***Test***

1.  Verify the index creation and mappings

> GET /product_index

2.  Verify the test documents are in the index

> GET /product_index/\_search

3.  Execute the aggregation query and confirm the results

> GET /product_index/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"categories\": {
>
> \"terms\": {
>
> \"field\": \"category\"
>
> },
>
> \"aggs\": {
>
> \"average_price\": {
>
> \"avg\": {
>
> \"field\": \"price\"
>
> }
>
> },
>
> \"price_ranges\": {
>
> \"range\": {
>
> \"field\": \"price\",
>
> \"ranges\": \[
>
> { \"to\": 20 },
>
> { \"from\": 20, \"to\": 40 },
>
> { \"from\": 40 }
>
> \]
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> **Results**
>
> { \...
>
> \"aggregations\": {
>
> \"categories\": {
>
> \"doc_count_error_upper_bound\": 0,
>
> \"sum_other_doc_count\": 0,
>
> \"buckets\": \[
>
> {
>
> \"key\": \"Apparel\",
>
> \"doc_count\": 2,
>
> \"average_price\": {
>
> \"value\": 16.49
>
> },
>
> \"price_ranges\": {
>
> \"buckets\": \[
>
> {
>
> \"key\": \"\*-20.0\",
>
> \"to\": 20,
>
> \"doc_count\": 2
>
> },
>
> {
>
> \"key\": \"20.0-40.0\",
>
> \"from\": 20,
>
> \"to\": 40,
>
> \"doc_count\": 0
>
> },
>
> {
>
> \"key\": \"40.0-\*\",
>
> \"from\": 40,
>
> \"doc_count\": 0
>
> }
>
> \]
>
> }
>
> },
>
> {
>
> \"key\": \"Books\",
>
> \"doc_count\": 2,
>
> \"average_price\": {
>
> \"value\": 34.99
>
> },
>
> \"price_ranges\": {
>
> \"buckets\": \[
>
> {
>
> \"key\": \"\*-20.0\",
>
> \"to\": 20,
>
> \"doc_count\": 0
>
> },
>
> {
>
> \"key\": \"20.0-40.0\",
>
> \"from\": 20,
>
> \"to\": 40,
>
> \"doc_count\": 2
>
> },
>
> {
>
> \"key\": \"40.0-\*\",
>
> \"from\": 40,
>
> \"doc_count\": 0
>
> }
>
> \]
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }

***Considerations***

-   The category field must be of type keyword

-   Setting "size" : 0 ensures the search doesn\'t return any documents,
    focusing solely on the aggregations.

-   The terms aggregation creates buckets for each unique category.

-   The avg sub-aggregation calculates the average price within each
    category bucket.

-   The range sub-aggregation divides the prices into specified ranges
    within each category bucket.

-   Setting size to 0 ensures that only aggregation results are
    returned, not individual documents. ***Clean-up (optional)***

> • Delete the index DELETE product_index

**Documentation**

-   [[Elasticsearch:
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)

-   [[Elasticsearch: Terms
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html)

-   [[Elasticsearch: Avg
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-avg-aggregation.html)

-   [[Elasticsearch: Range
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-aggregation.html)

### Example 2: Creating aggregations and sub-aggregations for Employee Data Analysis

***Requirements:***

-   Create a new index with four documents representing employee data

-   Use the terms aggregation to group employees by department

-   Use the avg sub-aggregation to calculate the average salary per
    department

-   Use the filters sub-aggregation to group employees by job_title
    ***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Create a new index called employees

> PUT employees
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"department\" : {
>
> \"type\": \"keyword\"
>
> },
>
> \"salary\" : {
>
> \"type\": \"integer\"
>
> },
>
> \"job_title\" : {
>
> \"type\": \"keyword\"
>
> }
>
> }
>
> }
>
> }
>
> 3\. Insert four documents representing employee data
>
> POST /employees/\_bulk
>
> {\"index\":{}}
>
> {\"department\":\"Sales\",\"salary\":100000,\"job_title\":\"Manager\"}
>
> {\"index\":{}}
>
> {\"department\":\"Sales\",\"salary\":80000,\"job_title\":\"Representative\"}
>
> {\"index\":{}}
>
> {\"department\":\"Marketing\",\"salary\":120000,\"job_title\":\"Manager\"}
>
> {\"index\":{}}
>
> {\"department\":\"Marketing\",\"salary\":90000,\"job_title\":\"Coordinator\"}
>
> 3\. Execute an aggregations by department
>
> GET /employees/\_search
>
> {
>
> \"size\" : 0,
>
> \"aggs\": {
>
> \"employees_by_department\": {
>
> \"terms\": {
>
> \"field\": \"department\"
>
> }
>
> }
>
> }
>
> }
>
> 4\. Add the sub-aggregations for average salary
>
> GET /employees/\_search
>
> {
>
> \"size\" : 0,
>
> \"aggs\": {
>
> \"employees_by_department\": {
>
> \"terms\": {
>
> \"field\": \"department\"
>
> },
>
> \"aggs\": {
>
> \"avg_salary\": {
>
> \"avg\": {
>
> \"field\": \"salary\"
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> 5\. Add a filter sub-aggregation for job_title
>
> GET /employees/\_search
>
> {
>
> \"size\" : 0,
>
> \"aggs\": {
>
> \"employees_by_department\": {
>
> \"terms\": {
>
> \"field\": \"department\"
>
> },
>
> \"aggs\": {
>
> \"avg_salary\": {
>
> \"avg\": {
>
> \"field\": \"salary\"
>
> }
>
> },
>
> \"employees_by_job_title\": {
>
> \"filters\": {
>
> \"filters\": {
>
> \"Manager\": {
>
> \"term\": {
>
> \"job_title\": \"Manager\"
>
> }
>
> },
>
> \"Representative\": {
>
> \"term\": {
>
> \"job_title\": \"Representative\"
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }

***Test***

1\. Verify that the employees are grouped correctly by department and
job title

> GET /employees/\_search
>
> {
>
> \"size\" : 0,
>
> \"aggs\": {
>
> \"employees_by_department\": {
>
> \"terms\": {
>
> \"field\": \"department\"
>
> },
>
> \"aggs\": {
>
> \"employees_by_job_title\": {
>
> \"filters\": {
>
> \"filters\": {
>
> \"Manager\": {
>
> \"term\": {
>
> \"job_title\": \"Manager\"
>
> }
>
> },
>
> \"Representative\": {
>
> \"term\": {
>
> \"job_title\": \"Representative\"
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }
>
> 2\. Verify that the average salary is calculated correctly for each
> department
>
> GET /employees/\_search
>
> {
>
> \"size\" : 0,
>
> \"aggs\": {
>
> \"employees_by_department\": {
>
> \"terms\": {
>
> \"field\": \"department\"
>
> },
>
> \"aggs\": {
>
> \"avg_salary\": {
>
> \"avg\": {
>
> \"field\": \"salary\"
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }

***Considerations***

-   The department field must be of type keyword

-   Setting \"size\" : 0 ensures the search doesn\'t return any
    documents, focusing solely on the aggregations.

-   The terms aggregation is used to group employees by department

-   The avg sub-aggregation is used to calculate the average salary per
    department

-   The filters sub-aggregation is used to group employees by job_title

***Clean-up (optional)*** • Delete the index

> DELETE employees

***Documentation***

-   [[Elasticsearch:
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)

-   [[Elasticsearch: Avg
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-avg-aggregation.html)

-   [[Elasticsearch: Filters
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/8.13/search-aggregations-bucket-filters-aggregation.html)

-   [[Elasticsearch: Range
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-aggregation.html)

-   [[Elasticsearch: Terms
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html)

### Example 3: Creating aggregations and sub-aggregations for application logs by Hour and Log Level

***Requirements***

-   Analyze application logs stored in an Elasticsearch index named
    app-logs.

-   Use a date histogram aggregation to group logs by the hour.

-   Within each hour bucket, create a sub-aggregation to group logs by
    their severity level (log_level).

***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Create a new index called app-logs

> PUT app-logs
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"@timestamp\" : {
>
> \"type\": \"date\"
>
> },
>
> \"log_level\" : {
>
> \"type\": \"keyword\"
>
> },
>
> \"message\" : {
>
> \"type\": \"text\"
>
> }
>
> }
>
> }
>
> }
>
> 3\. Insert sample data
>
> POST /app-logs/\_bulk
>
> {\"index\":{},\"\_id\":\"1\"}
>
> {\"@timestamp\":\"2024-05-24T10:30:00\",\"log_level\":\"INFO\",\"message\":\"Application
>
> started successfully.\"} {\"index\":{},\"\_id\":\"2\"}
>
> {\"@timestamp\":\"2024-05-
>
> 24T11:15:00\",\"log_level\":\"WARNING\",\"message\":\"Potential memory
> leak
>
> detected.\"}
>
> {\"index\":{},\"\_id\":\"3\"}
>
> {\"@timestamp\":\"2024-05-24T12:00:00\",\"log_level\":\"ERROR\",\"message\":\"Database
>
> connection failed.\"} {\"index\":{},\"\_id\":\"4\"}
>
> {\"@timestamp\":\"2024-05-24T10:45:00\",\"log_level\":\"DEBUG\",\"message\":\"Processing
> user request.\"}
>
> 2\. Use a date histogram aggregation to group logs by the hour
>
> GET /app-logs/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"logs_by_hour\": {
>
> \"date_histogram\": {
>
> \"field\": \"@timestamp\",
>
> \"fixed_interval\": \"1h\"
>
> }
>
> }
>
> }
>
> }

3\. Within each hour bucket, create a sub-aggregation to group logs by
their severity level

> (log_level)
>
> GET /app-logs/\_search
>
> {
>
> \"size\": 0,
>
> \"aggs\": {
>
> \"logs_by_hour\": {
>
> \"date_histogram\": {
>
> \"field\": \"@timestamp\",
>
> \"fixed_interval\": \"1h\"
>
> },
>
> \"aggs\": {
>
> \"log_levels\": {
>
> \"terms\": {
>
> \"field\": \"log_level\"
>
> }
>
> }
>
> }
>
> }
>
> }
>
> }

***Test***

>  Run the search query and examine the response
>
> { \...
>
> \"aggregations\": {
>
> \"logs_by_hour\": {
>
> \"buckets\": \[
>
> {
>
> \"key_as_string\": \"2024-05-24T10:00:00.000Z\",
>
> \"key\": 1716544800000,
>
> \"doc_count\": 2,
>
> \"log_levels\": {
>
> \"doc_count_error_upper_bound\": 0,
>
> \"sum_other_doc_count\": 0,
>
> \"buckets\": \[
>
> {
>
> \"key\": \"DEBUG\",
>
> \"doc_count\": 1
>
> },
>
> {
>
> \"key\": \"INFO\",
>
> \"doc_count\": 1
>
> }
>
> \]
>
> }
>
> },
>
> {
>
> \"key_as_string\": \"2024-05-24T11:00:00.000Z\",
>
> \"key\": 1716548400000,
>
> \"doc_count\": 1,
>
> \"log_levels\": {
>
> \"doc_count_error_upper_bound\": 0,
>
> \"sum_other_doc_count\": 0,
>
> \"buckets\": \[
>
> {
>
> \"key\": \"WARNING\",
>
> \"doc_count\": 1
>
> }
>
> \]
>
> }
>
> },
>
> {
>
> \"key_as_string\": \"2024-05-24T12:00:00.000Z\",
>
> \"key\": 1716552000000,
>
> \"doc_count\": 1,
>
> \"log_levels\": {
>
> \"doc_count_error_upper_bound\": 0,
>
> \"sum_other_doc_count\": 0,
>
> \"buckets\": \[
>
> {
>
> \"key\": \"ERROR\",
>
> \"doc_count\": 1
>
> }
>
> \]
>
> }
>
> }
>
> \]
>
> }
>
> }
>
> }

***Considerations***

-   Setting \"size\" : 0 ensures the search doesn\'t return any
    documents, focusing solely on the aggregations.

-   The date_histogram aggregation groups documents based on the
    \@timestamp field with an interval of one hour.

-   The nested terms aggregation within the logs_by_hour aggregation
    counts the occurrences of each unique log_level within each hour
    bucket. ***Clean-up (optional)*** • Delete the index

DELETE app-logs ***Documentation***

-   [[Bucket
    Aggregations]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket.html)

-   [[Date Histogram
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/8.13/search-aggregations-bucket-datehistogram-aggregation.html)

-   [[Terms
    Aggregation]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html)

## Task: Write and execute a query that searches across multiple clusters

If you are running your instance of Elasticsearch locally, and need to
create an additional cluster so that you can run these examples, go the
**Appendix: Adding a Cluster to your Elasticsearch Instance** for
information on how to set up an additional single-node cluster.

### Example 1: Creating search queries for Products in Multiple Clusters

***Requirements***

-   Set up two single-node clusters on localhost or Elastic Cloud

-   Create an index in each cluster

-   Index at least four documents in each cluster using the \_bulk
    endpoint

-   Configure cross-cluster search

-   Execute a cross-cluster search query

***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Set up multiple clusters on localhost

    -   Assume you have two clusters, es01 and es02 and they have been
        set up as directed in the **Appendix**.

    -   In the local cluster, configure communication between the
        clusters by updating the local cluster settings

> PUT /\_cluster/settings
>
> {
>
> \"persistent\": {
>
> \"cluster\": {
>
> \"remote\": {
>
> \"es01\": {
>
> \"seeds\": \[
>
> \"es01:9300\"
>
> \],
>
> \"skip_unavailable\": true
>
> },
>
> \"es02\": {
>
> \"seeds\": \[
>
> \"es02:9300\"
>
> \],
>
> \"skip_unavailable\": false
>
> }
>
> }
>
> }
>
> }
>
> }
>
> 3\. Create a product index in each cluster
>
> PUT /products
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"product\": {
>
> \"type\": \"text\"
>
> },
>
> \"category\": {
>
> \"type\": \"keyword\"
>
> },
>
> \"price\": {
>
> \"type\": \"double\"
>
> }
>
> }
>
> }
>
> }
>
> From the command line execute:
>
> curl -u elastic:\[your password here\] -X PUT
> \"http://localhost:9201/products?
>
> pretty\" -H \'Content-Type: application/json\' -d\'
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"product\": {
>
> \"type\": \"text\"
>
> },
>
> \"category\": {
>
> \"type\": \"keyword\"
>
> },
>
> \"price\": {
>
> \"type\": \"double\"
>
> }
>
> }
>
> }
>
> }\'
>
> 4\. Index product documents into each cluster
>
> POST /products/\_bulk
>
> { \"index\": { \"\_id\": \"1\" } }
>
> { \"product\": \"Elasticsearch Guide\", \"category\": \"Books\",
> \"price\": 29.99 }
>
> { \"index\": { \"\_id\": \"2\" } }
>
> { \"product\": \"Advanced Elasticsearch\", \"category\": \"Books\",
> \"price\": 39.99 }
>
> { \"index\": { \"\_id\": \"3\" } }
>
> { \"product\": \"Elasticsearch T-shirt\", \"category\": \"Apparel\",
> \"price\": 19.99 }
>
> { \"index\": { \"\_id\": \"4\" } }
>
> { \"product\": \"Elasticsearch Mug\", \"category\": \"Apparel\",
> \"price\": 12.99 } From the command line execute:
>
> curl -u elastic:\[your password here\] -X PUT
>
> \"http://localhost:9201/products/\_bulk?pretty\" -H \'Content-Type:
> application/json\' -d\' { \"index\": { \"\_id\": \"5\" } } {
> \"product\": \"Elasticsearch Stickers\", \"category\":
> \"Accessories\", \"price\":
>
> 4.99 }
>
> { \"index\": { \"\_id\": \"6\" } } { \"product\": \"Elasticsearch
> Notebook\", \"category\": \"Stationery\", \"price\":
>
> 7.99 }
>
> { \"index\": { \"\_id\": \"7\" } }
>
> { \"product\": \"Elasticsearch Pen\", \"category\": \"Stationery\",
> \"price\": 3.49 }
>
> { \"index\": { \"\_id\": \"8\" } }
>
> { \"product\": \"Elasticsearch Hoodie\", \"category\": \"Apparel\",
> \"price\": 45.99 }
>
> \'

5.  Configure Cross-Cluster Search (CCS)

>  In the local cluster, ensure the remote cluster is configured by
> checking the settings:
>
> GET /\_cluster/settings?
>
> include_defaults=true&filter_path=defaults.cluster.remote

6.  Execute a Cross-Cluster Search query

> GET /products,es02:products/\_search
>
> {
>
> \"query\": {
>
> \"match\": {
>
> \"product\": \"Elasticsearch\"
>
> }
>
> }
>
> }

***Test***

1.  Verify the index creation

>  Verify the mappings are correctly applied in both clusters.
>
> GET /products
>
> From the command line execute:
>
> curl -u elastic:\[your password here\] -X GET
> \"http://localhost:9201/products?
>
> pretty\"

2.  Verify that the documents have been indexed

> GET /products/\_search
>
> GET /es02:products/\_search

3.  Ensure the remote cluster is correctly configured and visible from
    the local cluster.

> GET /\_remote/info

4.  Execute a Cross-Cluster Search query

> GET /products,es02:products/\_search
>
> {
>
> \"query\": {
>
> \"match\": {
>
> \"product\": \"Elasticsearch\"
>
> }
>
> }
>
> }

***Considerations***

-   Cross-cluster search is useful for querying data across multiple
    Elasticsearch clusters, providing a unified search experience.

-   Ensure the remote cluster settings are correctly configured in the
    cluster settings.

-   Properly handle the index names to avoid conflicts and ensure clear
    distinction between clusters.

***Clean-up (optional)***

-   Delete the es01 index

> DELETE products

-   Delete the es02 index from the command line

curl -u elastic:\[your password here\] -X DELETE
\"http://localhost:9201/products?pretty\" ***Documentation***

-   [[Elasticsearch: Cross-Cluster
    Search]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-cross-cluster-search.html)

-   [[Elasticsearch: Create Index
    API]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html)

-   [[Elasticsearch: Bulk
    API]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html)

-   [[Elasticsearch: Index Document
    API]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html)

## Task: Write and execute a search that utilizes a runtime field

### Example 1: Creating search queries for products with a runtime field for discounted prices

***Requirements***

-   Create an index

-   Index four documents

-   Define a runtime field

-   Execute a search query that utilizes the query-time runtime field

***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Create an index

> PUT /product_index
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"product\": {
>
> \"type\": \"text\"
>
> },
>
> \"price\": {
>
> \"type\": \"double\"
>
> },
>
> \"category\": {
>
> \"type\": \"keyword\"
>
> }
>
> }
>
> }
>
> }

3.  Index some documents

> POST /product_index/\_bulk
>
> { \"index\": { \"\_id\": \"1\" } }
>
> { \"product\": \"Elasticsearch Guide\", \"price\": 29.99,
> \"category\": \"Books\" }
>
> { \"index\": { \"\_id\": \"2\" } }
>
> { \"product\": \"Advanced Elasticsearch\", \"price\": 39.99,
> \"category\": \"Books\" }
>
> { \"index\": { \"\_id\": \"3\" } }
>
> { \"product\": \"Elasticsearch T-shirt\", \"price\": 19.99,
> \"category\": \"Apparel\" }
>
> { \"index\": { \"\_id\": \"4\" } }
>
> { \"product\": \"Elasticsearch Mug\", \"price\": 12.99, \"category\":
> \"Apparel\" }

4.  Define a query-time runtime field

> GET /product_index/\_search
>
> {
>
> \"runtime_mappings\": {
>
> \"discounted_price\": {
>
> \"type\": \"double\",
>
> \"script\": {
>
> \"source\": \"emit(doc\[\'price\'\].value \* 0.9)\"
>
> }
>
> }
>
> },
>
> \"query\": {
>
> \"match_all\": {}
>
> },
>
> \"fields\": \[\"price\", \"discounted_price\"\]
>
> }

***Test***

1.  Verify the creation of the index and its mappings

> GET /product_index

2.  Verify the indexed documents

> GET /product_index/\_search

3.  Define the runtime field, and execute the query

> GET /product_index/\_search
>
> {
>
> \"runtime_mappings\": {
>
> \"discounted_price\": {
>
> \"type\": \"double\",
>
> \"script\": {
>
> \"source\": \"emit(doc\[\'price\'\].value \* 0.9)\"
>
> }
>
> }
>
> },
>
> \"query\": {
>
> \"match_all\": {}
>
> },
>
> \"fields\": \[\"price\", \"discounted_price\"\]
>
> }

***Considerations***

-   Runtime fields allow for dynamic calculation of field values at
    search time, useful for complex calculations or when the field
    values are not stored.

-   The script in the runtime field calculates the discounted price by
    applying a 10% discount to the price field.

***Clean-up (optional)***

• Delete the index

DELETE product_index ***Documentation***

-   [[Elasticsearch: Runtime
    Fields]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/runtime-search-request.html)

-   [[Elasticsearch: Create Index
    API]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html)

-   [[Elasticsearch: Bulk
    API]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html)

-   [[Elasticsearch: Index Document
    API]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html)

### Example 2: Creating search queries for employees with a calculated total salary

In this example, the runtime field defined as part of the index that
executes codes when documents are indexed. In this example, the salary
field is read at index time to create a new value for the runtime field
total_salary.

***Requirements***

-   An Elasticsearch index (employees) with documents containing
    employee information (name, department, salary)

-   A runtime field (total_salary) to calculate the total salary of each
    employee

-   A search query to retrieve employees with a total salary above a
    certain threshold

***Steps***

1.  **Open the Kibana Console** or use a REST client

2.  Create the employees index with a mapping for the runtime field

> PUT employees
>
> {
>
> \"mappings\": {
>
> \"properties\": {
>
> \"name\": {
>
> \"type\": \"text\"
>
> },
>
> \"department\": {
>
> \"type\": \"text\"
>
> },
>
> \"salary\": {
>
> \"type\": \"float\"
>
> },
>
> \"total_salary\": {
>
> \"type\": \"double\",
>
> \"on_script_error\": \"fail\",
>
> \"script\": {
>
> \"source\": \"emit(doc\[\'salary\'\].value \* 1.1)\"
>
> }
>
> }
>
> }
>
> }
>
> }

3.  Index some documents

> POST /employees/\_bulk
>
> { \"index\": { \"\_id\": \"1\" } }
>
> { \"name\": \"John Doe\", \"department\": \"Sales\", \"salary\": 50000
> }
>
> { \"index\": { \"\_id\": \"2\" } }
>
> { \"name\": \"Jane Smith\", \"department\": \"Marketing\", \"salary\":
> 60000 }
>
> { \"index\": { \"\_id\": \"3\" } }
>
> { \"name\": \"Bob Johnson\", \"department\": \"IT\", \"salary\": 70000
> }
>
> { \"index\": { \"\_id\": \"4\" } }
>
> { \"name\": \"Alice Brown\", \"department\": \"HR\", \"salary\": 55000
> }

4.  Execute a search query with a runtime field:

> GET /employees/\_search
>
> {
>
> \"query\": {
>
> \"range\": {
>
> \"total_salary\": {
>
> \"gt\": 65000
>
> }
>
> }
>
> }
>
> }

***Test***

-   Verify the creation of the index and its mappings

> GET /employees

-   Verify the indexed documents

> GET /employees/\_search

-   Execute the query and verify the search results contain only
    employees with a total salary above 65000

***Considerations***

-   Runtime fields are calculated on the fly and can be used in search
    queries, aggregations, and sorting.

-   The script used in the runtime field calculates the total salary by
    increasing the base salary by

> 10%.

***Clean-up (optional)*** • Delete the index

> DELETE employees

***Documentation***

-   [[Elasticsearch: Runtime
    Fields]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/runtime.html)

-   [[Elasticsearch Script
    Fields]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/8.13/search-fields.html#script-fields)

### Example 3: Creating search queries with a runtime field for restaurant data

***Requirements***

-   Search for restaurants based on their location (city and state)

-   Include the restaurant\'s name, cuisine type, and a calculated
    rating score in the search results

***Steps***

1.  **Open the Kibana Console** or use a REST client.

2.  Index some sample restaurant documents

> POST restaurants/\_bulk
>
> { \"index\": { \"\_id\": 1 } } { \"name\": \"Tasty Bites\", \"city\":
> \"New York\", \"state\": \"NY\", \"cuisine\":
>
> \"Italian\", \"review_score\": 4.5, \"number_of_reviews\": 200 }
>
> { \"index\": { \"\_id\": 2 } } { \"name\": \"Spicy Palace\", \"city\":
> \"Los Angeles\", \"state\": \"CA\", \"cuisine\":
>
> \"Indian\", \"review_score\": 4.2, \"number_of_reviews\": 150 }
>
> { \"index\": { \"\_id\": 3 } } { \"name\": \"Sushi Spot\", \"city\":
> \"San Francisco\", \"state\": \"CA\", \"cuisine\":
>
> \"Japanese\", \"review_score\": 4.7, \"number_of_reviews\": 300 }
>
> { \"index\": { \"\_id\": 4 } } { \"name\": \"Burger Joint\", \"city\":
> \"Chicago\", \"state\": \"IL\", \"cuisine\":
>
> \"American\", \"review_score\": 3.8, \"number_of_reviews\": 100 }
>
> 3\. Define a runtime field named weighted_rating to calculate a
> weighted rating score for New
>
> York restaurants
>
> GET restaurants/\_search
>
> {
>
> \"runtime_mappings\": {
>
> \"weighted_rating\": {
>
> \"type\": \"double\",
>
> \"script\": {
>
> \"source\": \"emit(Math.sqrt(doc\[\'review_score\'\].value \*
>
> doc\[\'number_of_reviews\'\].value))\"
>
> }
>
> }
>
> },
>
> \"query\": {
>
> \"bool\": {
>
> \"must\": \[
>
> {
>
> \"match\": {
>
> \"city\": \"New York\"
>
> }
>
> },
>
> {
>
> \"match\": {
>
> \"state\": \"NY\"
>
> }
>
> }
>
> \]
>
> }
>
> },
>
> \"fields\": \[
>
> \"name\",
>
> \"cuisine\",
>
> \"weighted_rating\"
>
> \]
>
> }

***Test***

-   Verify the creation of the index and its mappings

> GET /restaurants

-   Verify the indexed documents

> ◦ GET /restaurants/\_search
>
> ◦

-   Execute the query and verify the restaurant name, cuisine type, and
    the calculated weighted rating score for restaurants located in New
    York, NY.

***Considerations***

-   The runtime_mappings section defines a new field weighted_rating
    that calculates a weighted rating score based on the review_score
    and number_of_reviews fields.

-   The query section uses the match query to search for restaurants in
    New York, NY.

-   The fields section specifies the fields to include in the search
    results, including the runtime field weighted_rating. ***Clean-up
    (optional)*** • Delete the index

DELETE restaurants ***Documentation***

-   [[Runtime
    Fields]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/runtime.html)

-   [[Match
    Query]{.underline}](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)
